desc:PolyBLEP quasi-bandlimited tone generator

// Copyright (C) 2013-2018 Theo Niessink <theo@taletn.com>
// This work is free. You can redistribute it and/or modify it under the
// terms of the Do What The Fuck You Want To Public License, Version 2,
// as published by Sam Hocevar. See http://www.wtfpl.net/ for more details.

/* Example

   desc:Bandlimited sawtooth oscillator
   slider1:440<20,20000,1>Freq (Hz)

   import Tale/poly_blep.jsfx-inc

   @slider
   osc.poly_setf(slider1);

   @sample
   spl0 = spl1 = 0.25 * osc.poly_saw();

   Setting Functions

    * poly_setf(freq)
      Example: osc.poly_setf(440);
      Sets the oscillator frequency (specified in Hz), and returns the
      frequency in seconds/sample.

      (To convert from Hz to seconds/sample, divide by srate. To convert
      from seconds/sample to Hz, multiply with srate.)

      Note: Although the maximum frequency supported is srate/4, you can
      safely specify higher frequencies, even beyond srate/2.

    * poly_setf(note, tuning)
      Example: osc.poly_setf(60, 440);
      Sets the oscillator frequency to the specified MIDI note and tuning
      (in Hz), and returns the frequency in seconds/sample.

    * poly_setdt(time)
      Example: osc2.poly_setdt(osc1.dt);
      Sets the oscillator frequency (specified in seconds/sample), and
      returns this value.

    * poly_setpw(pw)
      Example: osc.poly_setpw(0.30);
      Sets the pulse width [0.0..1.0] of the waveform, and returns this
      value.

   Waveform Functions

    * poly_sin()     -- Sine
    * poly_cos()     -- Cosine
    * poly_tri()     -- Triangle
    * poly_sqr()     -- Square
    * poly_rect()    -- Rectangle (pulse)
    * poly_saw()     -- Sawtooth
    * poly_ramp()    -- Ramp

    * poly_tri2()    -- Modified triangle
    * poly_sqr2()    -- Modified square

    * poly_half()    -- Half-wave rectified sine (fixed 0.5 pulse width)
    * poly_half2()   -- Half-wave rectified sine (variable pulse width)
    * poly_full()    -- Full-wave rectified sine
    * poly_sinp()    -- Pulse sine
    * poly_trip()    -- Triangular pulse
    * poly_hwsaw()   -- Half-wave rectified sawtooth
    * poly_alt()     -- Alternating sine
    * poly_camel()   -- Camel sine

    * poly_sin2()    -- Bipolar squared sine
    * poly_para()    -- Parabola
    * poly_circ()    -- Circle
    * poly_trap()    -- Trapezoid (fixed 0.5 pulse width)
    * poly_trap2()   -- Trapezoid (variable pulse width)

    * poly_lpsqrN()  -- LPF square approximation (order N = 2 or 3)
    * poly_intsaw()  -- Integrated sawtooth
    * poly_hpsaw6()  -- HPF sawtooth approximation
    * poly_logit3()  -- Logit approximation

    * poly_ham()     -- Might not be suitable for vegetarians
    * poly_stairs()  -- Staircase (fixed 0.5 pulse width)
    * poly_stairs3() -- Staircase (variable pulse width)
    * poly_stairs2() -- Uneven staircase
      Example: sample = osc.poly_saw();
      Returns a sample of a waveform, and increments its phase.

      Note: In v20151024 the phase of poly_full() and poly_trip() has been
      corrected. To convert code relying on the old behavior, synchronize
      the phase to t-0.25 for poly_full(), and to t-(0.75+0.5*pw) for
      poly_trip().

   Miscellaneous Functions

    * poly_sync(phase)
      Example: osc2.poly_sync(osc1.t + 0.5);
      Synchronizes the oscillator with the specified phase, and returns the
      normalized phase.

      Note: You can safely specify out or range (and even negative) values
      here.

    * poly_inc()
      Example: osc.poly_inc();
      Increments the oscillator phase, and returns it.

      Note: All waveform functions automatically increment the phase.

    * poly_resetf()
      Example: osc.poly_resetf();
      Call this before changing the waveform to poly_stairs() or poly_ham().

    * poly_blep(t, dt)   -- Band-limited step
    * poly_blamp(t, dt)  -- Band-limited ramp
    * poly_blurve(t, dt) -- Band-limited curve
      Example: y = poly_blep(osc.t, osc.dt);
      Returns a polynomial around a discontinuity (i.e. when it passes 1.0
      and wraps to 0.0), or 0.0 otherwise.

   Instance Variables

    * t
      Example: phase = osc.t;
      The current phase [0.0..1.0) of the oscillator.

    * dt
      Example: freq = osc.dt * srate;
      The oscillator frequency, in seconds/sample.

    * pw
      Example: duty_cycle = osc.pw;
      The pulse width [0.0..1.0] of the waveform.

    * a
    * a2
    * a3
      Example: osc2.a = osc1.a;
      The frequency dependent gain [0.0..1.0].

*/

@init

function _poly_setdt(dt)
(
  dt <= 0.2 ? 1 : dt < 0.25 ? 1 - sqr(20 * (dt - 0.2));
  // 0 otherwise
);

function poly_setdt(time)
  instance(dt, a)
(
  a = _poly_setdt(time);
  dt = time;
);

function poly_setf(freq)
  // global(srate)
(
  this.poly_setdt(freq / srate);
);

function poly_setf(note, tuning)
  // global(srate)
(
  this.poly_setdt(exp(/* log(2)/12 */ 0.057762265046662109 * (note - 69)) * tuning / srate);
);

function poly_resetf()
  instance(dt2)
(
  dt2 = 0;
);

function poly_setpw(pw)
(
  this.pw = pw;
);

function poly_sync(phase)
  instance(t)
(
  t = phase;
  t >= 0 ? t -= t|0 : t += 1 - (t|0);
);

function poly_inc()
  instance(t, dt)
(
  t += dt;
  t -= t|0;
);

// Adapted from "Phaseshaping Oscillator Algorithms for Musical Sound
// Synthesis" by Jari Kleimola, Victor Lazzarini, Joseph Timoney, and Vesa
// Valimaki.
// http://www.acoustics.hut.fi/publications/papers/smc2010-phaseshaping/

function poly_blep(t, dt)
(
  t < dt ? (
    // x = t/dt
    // y = -(x^2) + 2*x - 1
    -sqr(1 - t/dt);
  ) :

  t > 1 - dt ? (
    // x = (t - 1) / dt
    // y = x^2 + 2*x + 1
    sqr(1 - (1 - t)/dt);
  );

  // 0 otherwise
);

// Derived from poly_blep().

function poly_blamp(t, dt)
(
  t < dt ? (
    // x = t/dt
    // y = -1/3*x^3 + x^2 - x + 1/3
    t = 1 - t/dt;
    1/3 * sqr(t)*t;
  ) :

  t > 1 - dt ? (
    // x = (t - 1) / dt
    // y = 1/3*x^3 + x^2 + x + 1/3
    t = 1 - (1 - t)/dt;
    1/3 * sqr(t)*t;
  );

  // 0 otherwise
);

function poly_blurve(t, dt)
(
  t < dt ? (
    // x = t/dt
    // y = -4*x^4 + 16*x^3 - 20*x^2 + 8*x
    t = sqr(1 - t/dt);
    4 * (t - sqr(t));
  ) :

  t > 1 - dt ? (
    // x = (t - 1) / dt
    // y = 4*x^4 + 16*x^3 + 20*x^2 + 8*x
    t = sqr(1 - (1 - t)/dt);
    4 * (sqr(t) - t);
  );

  // 0 otherwise
);

// Sine

function poly_sin()
  instance(a)
  local(t)
(
  t = this.t;
  this.poly_inc();

  a * sin(2*$pi * t);
);

// Cosine

function poly_cos()
  instance(a)
  local(t)
(
  t = this.t;
  this.poly_inc();

  a * cos(2*$pi * t);
);

// Half-wave rectified sine

// Note: Anti-aliasing depends on frequency and pulse width (pw == 1.0 is
// good, pw < 1.0 is increasingly not so good).

function poly_half()
  instance(dt, a)
  local(t1, t2, y, p)
(
  t1 = this.t;

  t2 = this.t + 0.5;
  t2 -= t2|0;

  this.poly_inc();

  t1 < 0.5 ? y = 2 * sin(2*$pi * t1) - 2/$pi : y = -2/$pi;

  // y += 2*$pi * dt * (poly_blamp(t1, dt) + poly_blamp(t2, dt));
  t1 < dt ? ( p = 1 - t1/dt; y += 2/3*$pi * dt * sqr(p)*p; ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += 2/3*$pi * dt * sqr(p)*p; );
  t2 < dt ? ( p = 1 - t2/dt; y += 2/3*$pi * dt * sqr(p)*p; ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y += 2/3*$pi * dt * sqr(p)*p; );

  a * y;
);

function poly_half2()
  instance(dt, a, pw)
  local(t1, t2, y, p)
(
  t1 = this.t + 0.5*pw + 0.75;
  t2 = this.t - 0.5*pw + 0.75;

  t1 -= t1|0;
  t2 -= t2|0;

  this.poly_inc();

  t1 < pw ? y = 2 * sin($pi * t1 / pw) - 4/$pi * pw : y = -4/$pi * pw;

  pw > 0 ? (
    // y += $pi * dt / pw * (poly_blamp(t1, dt) + poly_blamp(t2, dt));
    t1 < dt ? ( p = 1 - t1/dt; y += 1/3*$pi * dt/pw * sqr(p)*p; ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += 1/3*$pi * dt/pw * sqr(p)*p; );
    t2 < dt ? ( p = 1 - t2/dt; y += 1/3*$pi * dt/pw * sqr(p)*p; ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y += 1/3*$pi * dt/pw * sqr(p)*p; );
  );

  a * y;
);

// Full-wave rectified sine

function poly_full()
  instance(dt, a)
  local(t, y)
(
  t = this.t + 0.25;
  t -= t|0;

  this.poly_inc();

  y = 2 * sin($pi * t) - 4/$pi;

  // y += 2*$pi * dt * poly_blamp(t, dt);
  t < dt ? ( t = 1 - t/dt; y += 2/3*$pi * dt * sqr(t)*t; ) : t > 1 - dt ? ( t = 1 - (1 - t)/dt; y += 2/3*$pi * dt * sqr(t)*t; );

  a * y;
);

// Pulse sine

function poly_sinp()
  instance(dt, a)
  local(t1, t2, y, p)
(
  t1 = this.t;

  t2 = this.t + 0.5;
  t2 -= t2|0;

  this.poly_inc();

  t1 < 0.5 ? y = 2 * sin($pi * t1) - 2/$pi : y = -2/$pi;

  // y += $pi * dt * poly_blamp(t1, dt) - poly_blep(t2, dt);
  t1 < dt ? ( p = 1 - t1/dt; y += 1/3*$pi * dt * sqr(p)*p; ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += 1/3*$pi * dt * sqr(p)*p; );
  t2 < dt ? ( p = 1 - t2/dt; y += sqr(p); ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= sqr(p); );

  a * y;
);

// Alternating sine

function poly_alt()
  instance(dt, a)
  local(t1, t2, y, p)
(
  t1 = this.t;

  t2 = this.t + 0.5;
  t2 -= t2|0;

  this.poly_inc();

  t1 < 0.5 ? y = sin(4*$pi * t1) : y = 0;

  // y += 2*$pi * dt * (poly_blamp(t1, dt) - poly_blamp(t2, dt));
  t1 < dt ? ( p = 1 - t1/dt; y += 2/3*$pi * dt * sqr(p)*p; ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += 2/3*$pi * dt * sqr(p)*p; );
  t2 < dt ? ( p = 1 - t2/dt; y -= 2/3*$pi * dt * sqr(p)*p; ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= 2/3*$pi * dt * sqr(p)*p; );

  a * y;
);

// Camel sine

// Warning: Anti-aliasing doesn't work well at higher frequncies.

function poly_camel()
  instance(dt, a)
  local(t1, t2, t3, y, p)
(
  t1 = this.t;
  t2 = this.t + 0.75;
  t3 = this.t + 0.5;

  t2 -= t2|0;
  t3 -= t3|0;

  this.poly_inc();

  t1 < 0.5 ? y = 2 * abs(sin(4*$pi * t1)) - 2/$pi : y = -2/$pi;

  // y += 4*$pi * dt * (poly_blamp(t1, dt) + 2 * poly_blamp(t2, dt) + poly_blamp(t3, dt));
  t1 < dt ? ( p = 1 - t1/dt; y += 4/3*$pi * dt * sqr(p)*p; ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += 4/3*$pi * dt * sqr(p)*p; );
  t2 < dt ? ( p = 1 - t2/dt; y += 8/3*$pi * dt * sqr(p)*p; ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y += 8/3*$pi * dt * sqr(p)*p; );
  t3 < dt ? ( p = 1 - t3/dt; y += 4/3*$pi * dt * sqr(p)*p; ) : t3 > 1 - dt ? ( p = 1 - (1 - t3)/dt; y += 4/3*$pi * dt * sqr(p)*p; );

  a * y;
);

// Bipolar squared sine

function poly_sin2()
  instance(dt, a)
  local(t1, t2, y, p)
(
  t1 = this.t;

  t2 = this.t + 0.5;
  t2 -= t2|0;

  this.poly_inc();

  y = sqr(sin(2*$pi * t1));
  t1 >= 0.5 ? y = -y;

  // y += sqrt($pi) * sqr(dt) * (poly_blurve(t1, dt) - poly_blurve(t2, dt));
  t1 < dt ? ( p = sqr(1 - t1/dt); y -= 7.0898154036220641 * sqr(dt) * (sqr(p) - p); ) : t1 > 1 - dt ? ( p = sqr(1 - (1 - t1)/dt); y += 7.0898154036220641 * sqr(dt) * (sqr(p) - p); );
  t2 < dt ? ( p = sqr(1 - t2/dt); y += 7.0898154036220641 * sqr(dt) * (sqr(p) - p); ) : t2 > 1 - dt ? ( p = sqr(1 - (1 - t2)/dt); y -= 7.0898154036220641 * sqr(dt) * (sqr(p) - p); );

  a * y;
);

// Parabola

function poly_para()
  instance(dt, a)
  local(t1, t2, y, p)
(
  t1 = this.t;

  t2 = this.t + 0.5;
  t2 -= t2|0;

  this.poly_inc();

  t1 < 0.5 ? y = (-16*t1 + 8)*t1 : y = (16*t1 - 24)*t1 + 8;

  // y -= sqrt(0.5) * sqr(dt) * (poly_blurve(t1, dt) - poly_blurve(t2, dt));
  t1 < dt ? ( p = sqr(1 - t1/dt); y += 2.8284271247461901 * sqr(dt) * (sqr(p) - p); ) : t1 > 1 - dt ? ( p = sqr(1 - (1 - t1)/dt); y -= 2.8284271247461901 * sqr(dt) * (sqr(p) - p); );
  t2 < dt ? ( p = sqr(1 - t2/dt); y -= 2.8284271247461901 * sqr(dt) * (sqr(p) - p); ) : t2 > 1 - dt ? ( p = sqr(1 - (1 - t2)/dt); y += 2.8284271247461901 * sqr(dt) * (sqr(p) - p); );

  a * y;
);

// Circle

function poly_circ()
  instance(dt, a, lp)
  local(t1, t2, t3, y, p, lp.a)
(
  t1 = this.t + 0.015625; // 0.5/(n = 32)
  t2 = this.t + 0.515625; // 0.5/(n = 32) + 0.5
  t3 = this.t;

  t1 -= t1|0;
  t2 -= t2|0;

  this.poly_inc();

  // Mimic linear-phase filter by mixing 1st-order low-pass filtered
  // square...

  t1 < 0.5 ? y = 1 : y = -1;

  // y += poly_blep(t1, dt) - poly_blep(t2, dt);
  t1 < dt ? ( p = 1 - t1/dt; y -= sqr(p); ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += sqr(p); );
  t2 < dt ? ( p = 1 - t2/dt; y += sqr(p); ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= sqr(p); );

  // a = 1 / (1/(sqrt(n = 32)*2*$pi*dt) + 1)
  lp.a = dt / (0.028134884879909565 + dt);
  lp += lp.a * (y - lp);

  // ... with sine.
  a * 0.5 * (lp + sin(2*$pi * t3));
);

// Triangle

function poly_tri()
  instance(dt, a)
  local(t1, t2, y, p)
(
  t1 = this.t + 0.25;
  t2 = this.t + 0.75;

  t1 -= t1|0;
  t2 -= t2|0;

  y = this.t * 4;
  this.poly_inc();

  y >= 3 ? y -= 4 : y > 1 ? y = 2 - y;

  // y += 4*dt * (poly_blamp(t1, dt) - poly_blamp(t2, dt));
  t1 < dt ? ( p = 1 - t1/dt; y += 4/3 * dt * sqr(p)*p; ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += 4/3 * dt * sqr(p)*p; );
  t2 < dt ? ( p = 1 - t2/dt; y -= 4/3 * dt * sqr(p)*p; ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= 4/3 * dt * sqr(p)*p; );

  a * y;
);

// Modified triangle

function poly_tri2()
  instance(dt, a)
  local(pw, t1, t2, y, p)
(
  pw = max(0.0001, min(0.9999, this.pw));

  t1 = this.t + 0.5*pw;
  t2 = this.t - 0.5*pw + 1;

  t1 -= t1|0;
  t2 -= t2|0;

  y = this.t * 2;
  this.poly_inc();

  y >= 2 - pw ? y = (y - 2) / pw : y >= pw ? y = 1 - (y - pw) / (1 - pw) : y = y / pw;

  // y += dt/(pw - sqr(pw)) * (poly_blamp(t1, dt) - poly_blamp(t2, dt));
  t1 < dt ? ( p = 1 - t1/dt; y += 1/3 * dt/(pw - sqr(pw)) * sqr(p)*p; ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += 1/3 * dt/(pw - sqr(pw)) * sqr(p)*p; );
  t2 < dt ? ( p = 1 - t2/dt; y -= 1/3 * dt/(pw - sqr(pw)) * sqr(p)*p; ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= 1/3 * dt/(pw - sqr(pw)) * sqr(p)*p; );

  a * y;
);

// Triangular pulse

function poly_trip()
  instance(dt, a, pw)
  local(t1, t2, t3, y, p)
(
  t1 = this.t + 0.5*pw + 0.75;
  t2 = this.t + 0.75;
  t3 = this.t - 0.5*pw + 0.75;

  this.poly_inc();

  t1 -= t1|0;
  t2 -= t2|0;
  t3 -= t3|0;

  t1 < pw ? (
    y = 4*t1;
    y >= 2*pw ? y = 4 - y/pw - pw : y = y/pw - pw;
  ) : (
    y = -pw;
  );

  pw > 0 ? (
    // y += 2*dt / pw * (poly_blamp(t1, dt) - 2 * poly_blamp(t2, dt) + poly_blamp(t3, dt));
    t1 < dt ? ( p = 1 - t1/dt; y += 2/3 * dt/pw * sqr(p)*p; ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += 2/3 * dt/pw * sqr(p)*p; );
    t2 < dt ? ( p = 1 - t2/dt; y -= 4/3 * dt/pw * sqr(p)*p; ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= 4/3 * dt/pw * sqr(p)*p; );
    t3 < dt ? ( p = 1 - t3/dt; y += 2/3 * dt/pw * sqr(p)*p; ) : t3 > 1 - dt ? ( p = 1 - (1 - t3)/dt; y += 2/3 * dt/pw * sqr(p)*p; );
  );

  a * y;
);

// Trapezoid

function poly_trap()
  instance(dt, a)
  local(t1, t2, t3, t4, y, p)
(
  t1 = this.t + 0.125;
  t2 = this.t + 0.625;
  t3 = this.t + 0.375;
  t4 = this.t + 0.875;

  t1 -= t1|0;
  t2 -= t2|0;
  t3 -= t3|0;
  t4 -= t4|0;

  y = this.t * 4;
  y >= 3 ? y -= 4 : y > 1 ? y = 2 - y;

  this.poly_inc();

  y = max(-1, min(1, 2*y));

  // y += 4*dt * (poly_blamp(t1, dt) - poly_blamp(t2, dt) + poly_blamp(t3, dt) - poly_blamp(t4, dt));
  t1 < dt ? ( p = 1 - t1/dt; y += 4/3 * dt * sqr(p)*p; ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += 4/3 * dt * sqr(p)*p; );
  t2 < dt ? ( p = 1 - t2/dt; y -= 4/3 * dt * sqr(p)*p; ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= 4/3 * dt * sqr(p)*p; );
  t3 < dt ? ( p = 1 - t3/dt; y += 4/3 * dt * sqr(p)*p; ) : t3 > 1 - dt ? ( p = 1 - (1 - t3)/dt; y += 4/3 * dt * sqr(p)*p; );
  t4 < dt ? ( p = 1 - t4/dt; y -= 4/3 * dt * sqr(p)*p; ) : t4 > 1 - dt ? ( p = 1 - (1 - t4)/dt; y -= 4/3 * dt * sqr(p)*p; );

  a * y;
);

function poly_trap2()
  instance(dt, a)
  local(pw, t1, t2, t3, t4, y, p, scale)
(
  pw = min(0.9999, this.pw);

  t1 = this.t - 0.25*pw + 0.25;
  t2 = this.t - 0.25*pw + 0.75;
  t3 = this.t + 0.25*pw + 0.25;
  t4 = this.t + 0.25*pw + 0.75;

  t1 -= t1|0;
  t2 -= t2|0;
  t3 -= t3|0;
  t4 -= t4|0;

  y = this.t * 4;
  y >= 3 ? y -= 4 : y > 1 ? y = 2 - y;

  this.poly_inc();

  scale = 1/(1 - pw);
  y = max(-1, min(1, scale * y));

  // y += scale * 2*dt * (poly_blamp(t1, dt) - poly_blamp(t2, dt) + poly_blamp(t3, dt) - poly_blamp(t4, dt));
  t1 < dt ? ( p = 1 - t1/dt; y += 2/3 * scale * dt * sqr(p)*p; ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += 2/3 * scale * dt * sqr(p)*p; );
  t2 < dt ? ( p = 1 - t2/dt; y -= 2/3 * scale * dt * sqr(p)*p; ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= 2/3 * scale * dt * sqr(p)*p; );
  t3 < dt ? ( p = 1 - t3/dt; y += 2/3 * scale * dt * sqr(p)*p; ) : t3 > 1 - dt ? ( p = 1 - (1 - t3)/dt; y += 2/3 * scale * dt * sqr(p)*p; );
  t4 < dt ? ( p = 1 - t4/dt; y -= 2/3 * scale * dt * sqr(p)*p; ) : t4 > 1 - dt ? ( p = 1 - (1 - t4)/dt; y -= 2/3 * scale * dt * sqr(p)*p; );

  a * y;
);

// Square

function poly_sqr()
  instance(dt, a)
  local(t1, t2, y, p)
(
  t1 = this.t;

  t2 = this.t + 0.5;
  t2 -= t2|0;

  this.poly_inc();

  t1 < 0.5 ? y = 1 : y = -1;

  // y += poly_blep(t1, dt) - poly_blep(t2, dt);
  t1 < dt ? ( p = 1 - t1/dt; y -= sqr(p); ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += sqr(p); );
  t2 < dt ? ( p = 1 - t2/dt; y += sqr(p); ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= sqr(p); );

  a * y;
);

// Low-pass filtered square approximations

function poly_lpsqr2()
  instance(dt, a)
  local(t1, t2, y, p)
(
  t1 = this.t;

  t2 = this.t + 0.5;
  t2 -= t2|0;

  this.poly_inc();

  t1 < 0.5 ? y = 1 - 2 * sqr(1 - 2*t1) : y = 2 * sqr(2 - 2*t1) - 1;

  // y += 4*dt * (poly_blamp(t1, dt) - poly_blamp(t2, dt));
  t1 < dt ? ( p = 1 - t1/dt; y += 4/3 * dt * sqr(p)*p; ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += 4/3 * dt * sqr(p)*p; );
  t2 < dt ? ( p = 1 - t2/dt; y -= 4/3 * dt * sqr(p)*p; ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= 4/3 * dt * sqr(p)*p; );

  a * y;
);

function poly_lpsqr3()
  instance(dt, a)
  local(t1, t2, y, p)
(
  t1 = this.t;

  t2 = this.t + 0.5;
  t2 -= t2|0;

  this.poly_inc();

  t1 < 0.5 ? ( p = 1 - 2*t1; y = 1 - 2 * sqr(p)*p; ) : ( p = 2 - 2*t1; y = 2 * sqr(p)*p - 1; );

  // y += 6*dt * (poly_blamp(t1, dt) - poly_blamp(t2, dt));
  t1 < dt ? ( p = 1 - t1/dt; y += 2*dt * sqr(p)*p; ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += 2*dt * sqr(p)*p; );
  t2 < dt ? ( p = 1 - t2/dt; y -= 2*dt * sqr(p)*p; ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= 2*dt * sqr(p)*p; );

  a * y;
);

// Modified square

function poly_sqr2()
  instance(dt, a, pw)
  local(t1, t2, t3, t4, y, p)
(
  t1 = this.t + 0.25*pw + 0.75;
  t2 = this.t + 0.25*pw + 0.25;
  t3 = this.t - 0.25*pw + 0.25;
  t4 = this.t - 0.25*pw + 0.75;

  this.poly_inc();

  t1 -= t1|0;
  t2 -= t2|0;
  t3 -= t3|0;
  t4 -= t4|0;

  t1 < 0.5 ? y = 1 : y = -1;
  t3 < 0.5 ? y += 1 : y += -1;

  // y += poly_blep(t1, dt) - poly_blep(t2, dt) + poly_blep(t3, dt) - poly_blep(t4, dt);
  t1 < dt ? ( p = 1 - t1/dt; y -= sqr(p); ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += sqr(p); );
  t2 < dt ? ( p = 1 - t2/dt; y += sqr(p); ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= sqr(p); );
  t3 < dt ? ( p = 1 - t3/dt; y -= sqr(p); ) : t3 > 1 - dt ? ( p = 1 - (1 - t3)/dt; y += sqr(p); );
  t4 < dt ? ( p = 1 - t4/dt; y += sqr(p); ) : t4 > 1 - dt ? ( p = 1 - (1 - t4)/dt; y -= sqr(p); );

  a * 0.5*y;
);

// Rectangle

function poly_rect()
  instance(dt, a, pw)
  local(t1, t2, y, p)
(
  t1 = this.t;

  t2 = this.t + 1 - pw;
  t2 -= t2|0;

  this.poly_inc();

  y = -2*pw; t1 < pw ? y += 2;

  // y += poly_blep(t1, dt) - poly_blep(t2, dt);
  t1 < dt ? ( p = 1 - t1/dt; y -= sqr(p); ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += sqr(p); );
  t2 < dt ? ( p = 1 - t2/dt; y += sqr(p); ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= sqr(p); );

  a * y;
);

// Sawtooth

function poly_saw()
  instance(dt, a)
  local(t, y)
(
  t = this.t + 0.5;
  t -= t|0;

  this.poly_inc();

  y = 2*t - 1;

  // y -= poly_blep(t, dt);
  t < dt ? ( t = 1 - t/dt; y += sqr(t); ) : t > 1 - dt ? ( t = 1 - (1 - t)/dt; y -= sqr(t); );

  a * y;
);

// Ramp

function poly_ramp()
  instance(dt, a)
  local(t, y)
(
  t = this.t;
  this.poly_inc();

  y = 1 - 2*t;

  // y += poly_blep(t, dt);
  t < dt ? ( t = 1 - t/dt; y -= sqr(t); ) : t > 1 - dt ? ( t = 1 - (1 - t)/dt; y += sqr(t); );

  a * y;
);

// Integrated sawtooth

function poly_intsaw()
  instance(dt, a)
  local(t1, t2, y, p)
(
  t1 = this.t;

  t2 = this.t + 0.5;
  t2 -= t2|0;

  this.poly_inc();

  t1 < 0.5 ? y = 8*sqr(t1) - 2/3 : y = (8*t1 - 16)*t1 + 22/3;

  // y -= 8*dt * poly_blamp(t2, dt);
  t2 < dt ? ( p = 1 - t2/dt; y -= 8/3 * dt * sqr(p)*p; ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= 8/3 * dt * sqr(p)*p; );

  a * y;
);

// High-pass filtered sawtooth approximation

function poly_hpsaw6()
  instance(dt, a)
  local(t, y)
(
  t = 1.5 - this.t;
  t -= t|0;

  this.poly_inc();

  y = sqr(sqr(t)*t) * -2 + 2/7;

  // y += poly_blep(t, dt) + 6*dt * poly_blamp(t, dt);
  t < dt ? ( t = 1 - t/dt; y += (2*dt * sqr(t) - t)*t; ) : t > 1 - dt ? ( t = 1 - (1 - t)/dt; y += (2*dt * sqr(t) + t)*t; );

  a * y;
);

// Half-wave rectified sawtooth

function poly_hwsaw()
  instance(dt, a, pw)
  local(t1, t2, y, p)
(
  t1 = this.t + pw + 0.5;
  t2 = this.t + 0.5;

  this.poly_inc();

  t1 -= t1|0;
  t2 -= t2|0;

  t1 < pw ? y = 2*t1/pw - pw : y = -pw;

  // y += dt/pw * (poly_blamp(t1, dt) - poly_blamp(t2, dt)) - poly_blep(t2, dt);
  t1 < dt ? ( p = 1 - t1/dt; y += 1/3 * dt/pw * sqr(p)*p; ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += 1/3 * dt/pw * sqr(p)*p; );
  t2 < dt ? ( p = 1 - t2/dt; y -= (1/3 * dt/pw * sqr(p) - p)*p; ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= (1/3 * dt/pw * sqr(p) + p)*p; );

  a * y;
);

// Logit approximation

function poly_logit3()
  instance(dt, a)
  local(t, y)
(
  t = this.t + 0.5;
  t -= t|0;

  this.poly_inc();

  y = ((8*t - 12)*t + 6)*t - 1;

  // y -= poly_blep(t, dt);
  t < dt ? ( t = 1 - t/dt; y += sqr(t); ) : t > 1 - dt ? ( t = 1 - (1 - t)/dt; y -= sqr(t); );

  a * y;
);

// Staircase

function poly_stairs()
  instance(dt, a)
  local(t1, t2, t3, t4, y, p)
(
  t1 = this.t;
  t2 = this.t + 0.75;
  t3 = this.t + 0.5;
  t4 = this.t + 0.25;

  this.poly_inc();

  t2 -= t2|0;
  t3 -= t3|0;
  t4 -= t4|0;

  t1 < 0.25 ? y = 1 : t1 < 0.5 ? y = 1/3 : t1 < 0.75 ? y = -1/3 : y = -1;

  // y += poly_blep(t1, dt) - (poly_blep(t2, dt) + poly_blep(t3, dt) + poly_blep(t4, dt)) * 1/3;
  t1 < dt ? ( p = 1 - t1/dt; y -= sqr(p); ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += sqr(p); );
  t2 < dt ? ( p = 1 - t2/dt; y += 1/3 * sqr(p); ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= 1/3 * sqr(p); );
  t3 < dt ? ( p = 1 - t3/dt; y += 1/3 * sqr(p); ) : t3 > 1 - dt ? ( p = 1 - (1 - t3)/dt; y -= 1/3 * sqr(p); );
  t4 < dt ? ( p = 1 - t4/dt; y += 1/3 * sqr(p); ) : t4 > 1 - dt ? ( p = 1 - (1 - t4)/dt; y -= 1/3 * sqr(p); );

  a * y;
);

function poly_stairs3()
  instance(dt, a, pw)
  local(t1, t2, t3, t4, y, p)
(
  t1 = this.t;
  t2 = this.t - 0.5*pw + 1;
  t3 = this.t + 0.5;
  t4 = this.t - 0.5*pw + 0.5;

  this.poly_inc();

  t2 -= t2|0;
  t3 -= t3|0;
  t4 -= t4|0;

  2*t1 < pw ? y = -2/3*pw + 4/3 : t1 < 0.5 ? y = -2/3*pw + 2/3 : 2*t1 < pw + 1 ? y = -2/3*pw : y = -2/3*pw - 2/3;

  // y += poly_blep(t1, dt) - (poly_blep(t2, dt) + poly_blep(t3, dt) + poly_blep(t4, dt)) * 1/3;
  t1 < dt ? ( p = 1 - t1/dt; y -= sqr(p); ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += sqr(p); );
  t2 < dt ? ( p = 1 - t2/dt; y += 1/3 * sqr(p); ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= 1/3 * sqr(p); );
  t3 < dt ? ( p = 1 - t3/dt; y += 1/3 * sqr(p); ) : t3 > 1 - dt ? ( p = 1 - (1 - t3)/dt; y -= 1/3 * sqr(p); );
  t4 < dt ? ( p = 1 - t4/dt; y += 1/3 * sqr(p); ) : t4 > 1 - dt ? ( p = 1 - (1 - t4)/dt; y -= 1/3 * sqr(p); );

  a * y;
);

// Uneven staircase

function poly_stairs2()
  instance(dt, a, pw)
  local(t1, t2, t3, y, p)
(
  t1 = this.t;
  t2 = this.t - 0.5*pw + 1;
  t3 = this.t - 0.5*pw + 0.5;

  this.poly_inc();

  t2 -= t2|0;
  t3 -= t3|0;

  2*t1 < pw ? y = 1.5 - pw : 2*t1 < 1 + pw ? y = 0.5 - pw : y = -0.5 - pw;

  // y += poly_blep(t1, dt) - (poly_blep(t2, dt) + poly_blep(t3, dt)) * 0.5;
  t1 < dt ? ( p = 1 - t1/dt; y -= sqr(p); ) : t1 > 1 - dt ? ( p = 1 - (1 - t1)/dt; y += sqr(p); );
  t2 < dt ? ( p = 1 - t2/dt; y += 0.5 * sqr(p); ) : t2 > 1 - dt ? ( p = 1 - (1 - t2)/dt; y -= 0.5 * sqr(p); );
  t3 < dt ? ( p = 1 - t3/dt; y += 0.5 * sqr(p); ) : t3 > 1 - dt ? ( p = 1 - (1 - t3)/dt; y -= 0.5 * sqr(p); );

  a * y;
);

// Hammond 88 8000 000

function poly_ham()
  instance(dt, dt2, a, a2, a3)
  local(t)
(
  dt < dt2 || dt > dt2 ? (
    dt2 = dt;
    a2 = _poly_setdt(2*dt);
    a3 = _poly_setdt(3*dt);
  );

  t = this.t;
  this.poly_inc();

  0.4 // Approximation
  * (a * sin(2*$pi * t) + a2 * sin(4*$pi * t) + a3 * sin(6*$pi * t));
);

// Deprecated

function poly_leaky_set(rc) ( 0 );
function poly_leaky_reset() ( 0 );

function poly_init_full() ( 0 );
function poly_init_tri() ( 0 );
function poly_init_tri2() ( 0 );
function poly_init_half() ( 0 );
function poly_init_trap() ( 0 );
function poly_init_trip() ( 0 );
