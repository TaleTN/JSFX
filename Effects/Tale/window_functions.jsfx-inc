desc:Collection of window functions
// Copyright (C) 2015, 2016 Theo Niessink
// License: GPL - http://www.gnu.org/licenses/gpl.html

// Window functions from Wikipedia (unless noted otherwise).
// http://en.wikipedia.org/wiki/Window_function

/* Example

   desc:Low-pass windowed FIR filter
   slider1:1000<20,20000,1>Cutoff (Hz)
   slider2:1<0,1,1{Rectangular,Blackman}>Window Function

   import Tale/window_functions.jsfx-inc

   @init

   fir_len = floor(64 / 44100 * srate + 0.5);

   in_buf = 0;
   fir_buf = in_buf + fir_len;

   pdc_bot_ch = 0; pdc_top_ch = 2;
   pdc_delay = floor(fir_len / 2);

   @slider

   // Source: http://www.labbookpages.co.uk/audio/firWindowing.html

   m = fir_len - 1;
   ft = min(0.5, slider1 / srate);

   n = avg = 0;
   loop(fir_len,
     // Low-pass filter.
     lpf = n != m/2 ? sin(2*$pi*ft*(n - m/2)) / ($pi*(n - m/2)) : 2*ft;

     // Apply window.
     slider2 >= 0.5 ? lpf *= wnd_blackman(n, fir_len);
     avg += lpf;

     fir_buf[n] = lpf;
     n += 1;
   );

   scale = 1/avg;

   @sample

   // Buffer input.
   in_buf[idx] = 0.5 * (spl0 + spl1);
   (idx += 1) >= fir_len ? idx = 0;

   // Convolve with FIR filter.
   sum = n = 0;
   i = idx;
   loop(fir_len,
     sum += fir_buf[n] * in_buf[i];
     n += 1;
     (i += 1) >= fir_len ? i = 0;
   );

   spl0 = spl1 = sum * scale;

   Window Functions

    * wnd_rect(i, n)                    -- Rectangular
    * wnd_tri(i, n, l)                  -- Triangular
    * wnd_bartlett(i, n)                -- Bartlett
    * wnd_parzen(i, n)                  -- Parzen
    * wnd_welch(i, n)                   -- Welch

    * wnd_hann(i, n)                    -- Hann
    * wnd_hamming(i, n[, alpha, beta])  -- Hamming (default: alpha=0.54, beta=0.46)

    * wnd_cos(i, n, a0..a2/a3/a4)       -- Higher-order generalised cosine
    * wnd_blackman(i, n[, alpha])       -- Blackman (default: alpha=0.16)
    * wnd_nuttall(i, n)                 -- Nuttall
    * wnd_blackman_nuttall(i, n)        -- Blackman-Nuttall
    * wnd_blackman_harris(i, n)         -- Blackman-Harris
    * wnd_flat_top(i, n)                -- SRS flat top

    * wnd_pow_cos(i, n, alpha)          -- Power-of-cosine
    * wnd_cos(i, n)                     -- Cosine
    * wnd_bohman(i, n)                  -- Bohman

    * wnd_gaussian(i, n, sigma)         -- Gaussian
    * wnd_gaussian(i, n, sigma, p)      -- Generalised normal
    * wnd_tukey(i, n, alpha)            -- Tukey
    * wnd_kaiser(i, n, alpha)           -- Kaiser
    * wnd_poisson(i, n, alpha)          -- Poisson

    * wnd_bartlett_hann(i, n)           -- Bartlett-Hann
    * wnd_hann_poisson(i, n, alpha)     -- Hann-Poisson

    * wnd_lanczos(i, n)                 -- Lanczos
    * wnd_cauchy(i, n, alpha)           -- Cauchy
    * wnd_connes(i, n, alpha)           -- Connes
      Example: y = wnd_blackman(0, 1024);
      Returns the normalised window function for integers i = [0..n-1],
      n >= 16.

   Average Functions

    * wnd_tri_avg(n, l)                 -- Triangular
    * wnd_bartlett_avg(n)               -- Bartlett
    * wnd_parzen_avg(n)                 -- Parzen
    * wnd_welch_avg(n)                  -- Welch

    * wnd_hamming_avg(n[, alpha, beta]) -- Hamming
    * wnd_hann_avg(n)                   -- Hann

    * wnd_cos_avg(n, a0..a2/a3/a4)      -- Higher-order generalised cosine
    * wnd_blackman_avg(n[, alpha])      -- Blackman
    * wnd_nuttall_avg(n)                -- Nuttall
    * wnd_blackman_nuttall_avg(n)       -- Blackman-Nuttall
    * wnd_blackman_harris_avg(n)        -- Blackman-Harris
    * wnd_flat_top_avg(n)               -- SRS flat top

    * wnd_bartlett_hann_avg(n)          -- Bartlett-Hann
      Example: avg = wnd_blackman_avg(1024);
      Returns the average of the normalised window function.

      Note: To preserve the signal's gain you will need to scale the
      windowed signal by 1/avg.

   Miscellaneous Functions

    * _wnd_i0(x)
      Example: y = _wnd_i0(3*$pi);
      Approximates the zero-th order modified Bessel function of the first
      kind.

    * _wnd_kaiser(i, n, alpha)
      Example: y = _wnd_kaiser(0, 1024, 3);
      Returns the non-normalised Kaiser window function. To normalise divide
      by _wnd_i0($pi*alpha).

*/

@init


// Rectangular (aka Dirichlet)

function wnd_rect(i, n)
(
  // wnd_pow_cos(i, n, 0);
  1;
);

// avg = 1;
// eq_noise_bw = 1;


// Triangular

// l == n || l == n+1 || l = n-1

function wnd_tri(i, n, l)
(
  1 - abs((2*i - (n - 1)) / l);
);

function wnd_tri_avg(n, l)
(
  l == n+1 ? 0.5 + 0.5 / (2 * (( n      / 2)|0) + 1) :
  l == n-1 ? 0.5 - 0.5 / (2 * (((n + 1) / 2)|0) - 1) :
  l == n   ? ( n & 1 ? 0.5 + 0.5 / (n*n) : 0.5 );
);

// eq_noise_bw = 4/3;


// Bartlett (aka Fejer)

// n >= 3

function wnd_bartlett(i, n)
(
  // wnd_tri(i, n, n - 1);
  1 - abs(2*i / (n - 1) - 1);
);

function wnd_bartlett_avg(n)
(
  0.5 - 0.5 / (2 * (((n + 1) / 2)|0) - 1);
);

// eq_noise_bw = 4/3;


// Parzen (aka de la Vallee Poussin)

function wnd_parzen(i, n) 
(
  n *= 0.5;
  i = abs(i - (n - 0.5));

  i < 0.5*n ? (
    i = i / n;
    1 - 6*i*i * (1 - i);
  ) : (
    i = 1 - i / n;
    2*i*i*i;
  );
);

function wnd_parzen_avg(n)
(
  n & 1 ? 0.375 + 0.625 / (n*n*n*n) :
  n & 3 ? 0.375 - 2 / (n*n*n*n) :
  0.375;
);

// eq_noise_bw = 1.92;


// Welch (aka Riesz)

function wnd_welch(i, n)
(
  1 - sqr(2*i / (n - 1) - 1);
);

function wnd_welch_avg(n)
(
  2/3 - 2/3 / (n - 1);
);

// eq_noise_bw = 1.20;


// Generalised Hamming

// alpha >= 0.5 && alpha <= 1.0, beta = 1.0 - alpha

function wnd_hamming(i, n, alpha, beta)
(
  alpha - beta * cos(2*$pi * i / (n - 1));
);

function wnd_hamming_avg(n, alpha, beta)
(
  // n < 3 ? alpha - beta :
  alpha - beta / n;
);

// eq_noise_bw = ?


// Hann (aka Hanning)

function wnd_hann(i, n)
(
  // wnd_hamming(i, n, 0.5, 0.5);
  // wnd_pow_cos(i, n, 2);

  0.5 * (1 - cos(2*$pi * i / (n - 1)));
);

function wnd_hann_avg(n)
(
  wnd_hamming_avg(n, 0.5, 0.5);
);

// eq_noise_bw = 1.5;


// Hamming

function wnd_hamming(i, n)
(
  wnd_hamming(i, n, 0.54, 0.46); // Original
  // wnd_hamming(i, n, 25/46, 21/46); // Exact
  // wnd_hamming(i, n, 0.53836, 0.46164); // Optimal
);

function wnd_hamming_avg(n)
(
  wnd_hamming_avg(n, 0.54, 0.46);
);


// Higher-order generalised cosine

function wnd_cos(i, n, a0, a1, a2)
(
  i *= 2*$pi / (n - 1);
  a0 - a1 * cos(i) + a2 * cos(2*i);
);

function wnd_cos_avg(n, a0, a1, a2)
(
  // n < 3 ? a0 - a1 + a2 :
  // n < 4 ? a0 - 1/3 * a1 + a2 :
  a0 - (a1 - a2) / n;
);

function wnd_cos(i, n, a0, a1, a2, a3)
(
  i *= 2*$pi / (n - 1);
  a0 - a1 * cos(i) + a2 * cos(2*i) - a3 * cos(3*i);
);

function wnd_cos_avg(n, a0, a1, a2, a3)
(
  // n < 3 ? a0 - a1 + a2 - a3 :
  // n < 4 ? a0 - 1/3 * (a1 + a3) + a2 :
  // n < 5 ? a0 - 0.25 * (a1 - a2) - a3 :
  a0 - (a1 - a2 + a3) / n;
);

function wnd_cos(i, n, a0, a1, a2, a3, a4)
(
  i *= 2*$pi / (n - 1);
  a0 - a1 * cos(i) + a2 * cos(2*i) - a3 * cos(3*i) + a4 * cos(4*i);
);

function wnd_cos_avg(n, a0, a1, a2, a3, a4)
(
  // n < 3 ? a0 - a1 + a2 - a3 + a4 :
  // n < 4 ? a0 - 1/3 * (a1 + a3) + a2 + a4 :
  // n < 5 ? a0 - 0.25 * (a1 - a2 - a4) - a3 :
  // n < 6 ? a0 - 0.2 * (a1 - a2 + a3) + a4 :
  a0 - (a1 - a2 + a3 - a4) / n;
);

// eq_noise_bw = ?


// Blackman

// alpha >= -0.25 && alpha <= 0.25

function wnd_blackman(i, n, alpha)
(
  // wnd_cos(i, n, 0.5 * (1 - alpha), 0.5, 0.5 * alpha);
  i *= 2*$pi / (n - 1);
  0.5 * (1 - cos(i) - alpha * (1 - cos(2*i)));
);

function wnd_blackman_avg(n, alpha)
(
  // wnd_cos_avg(i, n, 0.5 * (1 - alpha), 0.5, 0.5 * alpha);

  // n < 3 ? 0 :
  // n < 4 ? 1/3 :
  0.5 * (1 - alpha) * (1 - 1/n);
);

function wnd_blackman(i, n)
(
  // wnd_blackman(i, n, 0.16); // Approximation
  // wnd_cos(i, n, 7938/18608, 9240/18608, 1430/18608); // Exact

  // Approximation
  i *= 2*$pi / (n - 1);
  0.42 - 0.5 * cos(i) + 0.08 * cos(2*i);
);

function wnd_blackman_avg(n)
(
  // wnd_blackman_avg(n, 0.16);

  // n < 3 ? 0 :
  // n < 4 ? 1/3 :
  0.42 - 0.42/n;
);

// eq_noise_bw = alpha == 0.16 ? 1.73;


// Nuttall

function wnd_nuttall(i, n)
(
  wnd_cos(i, n, 0.355768, 0.487396, 0.144232, 0.012604);
);

function wnd_nuttall_avg(n)
(
  wnd_cos_avg(n, 0.355768, 0.487396, 0.144232, 0.012604);
);

// eq_noise_bw = 2.0212;


// Blackman-Nuttall

function wnd_blackman_nuttall(i, n)
(
  wnd_cos(i, n, 0.3635819, 0.4891775, 0.1365995, 0.0106411);
);

function wnd_blackman_nuttall_avg(i, n)
(
  wnd_cos_avg(n, 0.3635819, 0.4891775, 0.1365995, 0.0106411);
);

// eq_noise_bw = 1.9761;


// Blackman-Harris

function wnd_blackman_harris(i, n)
(
  wnd_cos(i, n, 0.35875, 0.48829, 0.14128, 0.01168);
);

function wnd_blackman_harris_avg(n)
(
  wnd_cos_avg(n, 0.35875, 0.48829, 0.14128, 0.01168);
);

// eq_noise_bw = 2.0044;


// Flat top

function wnd_flat_top(i, n)
(
  // SRS flat top from Wikipedia.
  // http://en.wikipedia.org/wiki/Window_function#Flat_top_window
  wnd_cos(i, n, 1/4.636, 1.93/4.636, 1.29/4.636, 0.388/4.636, 0.028/4.636);

  // Alternate flat top coefficients from:
  // http://janroman.dhis.org/AFI/Python/spectrum/src/spectrum/window.py
  // wnd_cos(i, n, 0.21557895, 0.41663158, 0.277263158, 0.083578947, 0.006947368);
  // wnd_cos(i, n, 1/4.6402, 1.93/4.6402, 1.29/4.6402, 0.388/4.6402, 0.0322/4.6402);
);

function wnd_flat_top_avg(n)
(
  wnd_cos_avg(n, 1/4.636, 1.93/4.636, 1.29/4.636, 0.388/4.636, 0.028/4.636);
);

// eq_noise_bw = 3.7702;


// Rife-Vincent class I

// p >= 1 && p <= 14

function wnd_rife_vincent(i, n, p)
  local(scale, sum, prod, j, k)
(
  p == 1 ? wnd_hann(i, n) :
  p == 2 ? wnd_cos(i, n, 0.375, 0.5, 0.125) :
  p == 3 ? wnd_cos(i, n, 0.3125, 0.46875, 0.1875, 0.03125) :
  p == 4 ? wnd_cos(i, n, 0.2734375, 0.4375, 0.21875, 0.0625, 0.0078125) :

  // Source: http://www.mathworks.com/matlabcentral/fileexchange/46092-window-utilities/content/rifevwin.m
  (
    i *= 2*$pi / (n - 1);
    scale = sum = 0;
    j = 1;
    loop(p,
      prod = k = 1;
      loop(j,
        prod *= (p - k + 1) / (p + k);
        k += 1;
      );
      scale += prod;
      j & 1 ? prod = -prod;
      sum += prod * cos(i*j);
      j += 1;
    );
    (1 + 2*sum) / (1 + 2*scale);
  );
);

function wnd_rife_vincent_avg(i, n, p)
  local(scale, sum, prod, j, k)
(
  p == 1 ? wnd_hann_avg(n) :
  p == 2 ? wnd_cos_avg(n, 0.375, 0.5, 0.125) :
  p == 3 ? wnd_cos_avg(n, 0.3125, 0.46875, 0.1875, 0.03125) :
  p == 4 ? wnd_cos_avg(n, 0.2734375, 0.4375, 0.21875, 0.0625, 0.0078125) :
  (
    scale = sum = 0;
    j = 1;
    loop(p,
      prod = k = 1;
      loop(j,
        prod *= (p - k + 1) / (p + k);
        k += 1;
      );
      scale += prod;
      j & 1 ? prod = -prod;
      sum += prod;
      j += 1;
    );
    (1 + 2*sum / n) / (1 + 2*scale);
  );
);

// eq_noise_bw = ?


// Power-of-cosine

// alpha >= 0

function wnd_pow_cos(i, n, alpha)
(
  sin($pi * i / (n - 1))^alpha;
);

// avg = ?
// eq_noise_bw = ?


// Cosine (aka sine)

function wnd_cos(i, n)
(
  // wnd_pow_cos(i, n, 1);
  sin($pi * i / (n - 1));
);

// avg = ?
// eq_noise_bw = 1.23;


// Bohman

function wnd_bohman(i, n)
( 
  // Source: http://janroman.dhis.org/AFI/Python/spectrum/src/spectrum/window.py
  i = abs(2*i / (n - 1) - 1);
  (1 - i) * cos($pi * i) + sin($pi * i) / $pi;
);

// avg = ?
// eq_noise_bw = 1.79;


// Gaussian

// sigma > 0.0 && sigma <= 0.5

function wnd_gaussian(i, n, sigma)
(
  n = 0.5 * (n - 1);
  exp(-0.5 * sqr((i - n) / (sigma * n)));
);

// avg = ?
// eq_noise_bw = sigma == 0.4 ? 1.45;


// Generalised normal

// p > 0 && !(p & 1)

function wnd_gaussian(i, n, sigma, p)
(
  n = 0.5 * (n - 1);
  exp(-(((i - n) / (sigma * n))^p));
);

// avg = ?
// eq_noise_bw = ?


// Tukey

// alpha > 0.0 && alpha <= 1.0

function wnd_tukey(i, n, alpha)
  local(m)
(
  n -= 1;
  alpha *= 0.5;
  m = alpha * n;

  /* i >= 0 && */ i < m ? 0.5 * (1 + cos($pi * (i / m - 1))) :
  i <= n - m ? 1 :
  /* i <= n ? */ 0.5 * (1 + cos($pi * (i / m - 1/alpha + 1)));
);

// avg = ?
// eq_noise_bw = alpha == 0.5 ? 1.22;


// Kaiser (aka Kaiser-Bessel)

function _wnd_i0(x)
  local(x2, fact, y, i)
(
  x2 = x = 0.25*x*x;
  fact = y = i = 1;
  loop(20,
    y += x / (fact*fact);
    x *= x2;
    fact *= (i += 1);
  );
  y;
);

// alpha >= 0.0

function _wnd_kaiser(i, n, alpha)
(
  _wnd_i0($pi * alpha * sqrt(1 - sqr(2*i / (n - 1) - 1)));
);

function wnd_kaiser(i, n, alpha)
(
  _wnd_kaiser(i, n, alpha) / _wnd_i0($pi * alpha);
);

// avg = ?
// eq_noise_bw = alpha == 2 ? 1.4963 : alpha == 3 ? 1.7952;


// Poisson (exponential)

// alpha >= 0.0

function wnd_poisson(i, n, alpha)
(
  // Source: http://janroman.dhis.org/AFI/Python/spectrum/src/spectrum/window.py
  i = abs(n * (i / (n - 1) - 0.5));
  exp(-2*i / n * alpha);
);

// avg = ?
// eq_noise_bw = alpha == 2 ? 1.3;


// Bartlett-Hann

function wnd_bartlett_hann(i, n)
(
  i /= n - 1;
  0.62 - 0.48 * abs(i - 0.5) - 0.38 * cos(2*$pi * i);
);

function wnd_bartlett_hann_avg(n)
(
  0.12 - 0.12/n;
);

// eq_noise_bw = 1.46;


// Hann-Poisson (aka Poisson-Hanning)

function wnd_hann_poisson(i, n, alpha)
(
  wnd_hann(i, n) * wnd_poisson(i, n, alpha);
);

// avg = ?
// eq_noise_bw = alpha == 2 ? 2.02;


// Cauchy

// alpha >= 0.0

function wnd_cauchy(i, n, alpha)
(
  // Source: http://janroman.dhis.org/AFI/Python/spectrum/src/spectrum/window.py
  1/(1 + sqr(2*alpha * (i / (n - 1) - 0.5)));
);

// avg = ?
// eq_noise_bw = alpha == 3 ? 2.02;


// Lanczos (aka Riemann)

function wnd_lanczos(i, n)
  local(x)
(
  x = $pi * (2*i / (n - 1) - 1);
  x < 0 || x > 0 ? sin(x)/x : 1;
);

// avg = ?
// eq_noise_bw = 1.30;


// Connes

// alpha >= 1

function wnd_connes(i, n, alpha)
(
  // Source: https://reference.wolfram.com/language/ref/ConnesWindow.html
  i = i / (n - 1) - 0.5;
  alpha *= alpha;
  sqr(-4*i*i + alpha) / (alpha*alpha);
);

// avg = ?
// eq_noise_bw = ?
