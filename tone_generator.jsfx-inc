desc:Fourier series bandlimited tone generator
// (c) Theo Niessink 2012
// License: GPL <http://www.gnu.org/licenses/gpl.html>

/* Example #1:

   desc:Bandlimited sawtooth oscillator
   slider1:440<20,12000,1>Frequency (Hz)

   import tone_generator.jsfx-inc

   @slider
   tg.tg_setf(slider1);

   @sample
   spl0 = spl1 = 0.5 * tg.tg_saw();

   Example #2:

   desc:Bandlimited rectangular oscillator
   slider1:440<20,12000,1>Frequency (Hz)
   slider2:0.30<0.10,0.90,0.01>Pulse Width

   import tone_generator.jsfx-inc

   @init

   // Store the cache at local memory index 0, and select 20.0 Hz as the
   // lowest frequency (= maximum cache size).
   tg.tg_init_rect(0, 20.0);

   @slider
   tg.tg_setf(max(20.0, slider1));
   tg.tg_setpw(slider2);

   @sample
   spl0 = spl1 = 0.5 * tg.tg_rect();

   Example #3:

   desc:Bandlimited triangular oscillator with vibrato
   slider1:440<20,12000,1>Oscillator (Hz)
   slider2:5<1,10,0.1>Vibrato (Hz)

   import tone_generator.jsfx-inc
   import lfo.jsfx-inc

   @slider
   tg.tg_setf(slider1);
   lfo.lfo_setf(slider2);

   @sample
   tg.tg_sync(tg.t + tg.dt * 2^(lfo.lfo_sin() * 0.35/12));
   spl0 = spl1 = 0.5 * tg._tg_tri(tg.t);

*/

@init


function tg_setbw(bw)
(
  bw <= 0 ? (
    this.bw <= 0 ? this.bw = min(12000, 0.5 * srate) : this.bw;
  ) : bw > 0.5 ? (
    this.bw = min(bw, 0.5 * srate);
  ) : (
    this.bw = bw * srate;
  );
);


function tg_setf(f)
  instance(bw, n, a, dt)
  local(f0, f1)
(
  this.tg_setbw(0);
  n = ceil(bw / f);

  n > 1 ? (
    f0 = bw / n;
    f1 = bw / (n - 1);
    a = sqrt((f1 - f) / (f1 - f0));
  ) : (
    a = 0.0;
  );

  dt = 2*$pi / srate * f;
);


function tg_sync(t)
(
  t >= 2*$pi || t < 0 ? (
    t /= 2*$pi;
    t = (t - floor(t)) * 2*$pi;
  );
  this.t = t;
);


function tg_inc()
  instance(t, dt)
(
  t += dt;

  t < 2*$pi ? t : (t -= 2*$pi) < 2*$pi ? t : (
    t /= 2*$pi;
    t = (t - (t|0)) * 2*$pi;
  );
);


function tg_falloff(s)
  instance(n, a)
(
  n > 2 ? s : n > 1 ? a * s : 0.0;
);


// Sine

function _tg_sin(t)
(
  this.tg_falloff(sin(t));
);

function tg_sin()
  local(t)
(
  t = this.t;
  this.tg_inc();
  this._tg_sin(t);
);


// Half-wave rectified sine

function _tg_half(t)
  instance(dt, a)
  local(n, s)
(
  // Naive
  n = dt * 8;
  t >= $pi + n && t <= 2*$pi - n ? (
    this.tg_falloff(-2/$pi);
  ) : t >= n && t <= $pi - n ? (
    this.tg_falloff(-2/$pi + 2 * sin(t));

  // Fourier series
  ) : (
    s = 0.0;
    n = 2;
    loop((this.n - 2) / 2,
      s += cos(n * t) / (n*n - 1);
      n += 2;
    );
    n < this.n ? s += a * cos(n * t) / (n*n - 1);
    this.tg_falloff(sin(t) - 4/$pi * s);
  );
);

function tg_half()
  local(t)
(
  t = this.t;
  this.tg_inc();
  this._tg_half(t);
);


// Full-wave rectified sine

function _tg_full(t)
  instance(dt, a)
  local(n, s)
(
  n = dt * 10;
  t >= n && t <= 2*$pi - n ? (
    this.tg_falloff(2 * sin(0.5 * t) - 4/$pi);

  ) : (
    s = 0.0;
    n = 1;
    loop(this.n - 2,
      s += cos(n * t) / (4 * n*n - 1);
      n += 1;
    );
    n < this.n ? s += a * cos(n * t) / (4 * n*n - 1);
    (-8/$pi) * s;
  );
);

function tg_full()
  local(t)
(
  t = this.t;
  this.tg_inc();
  this._tg_full(t);
);


// Circle

function tg_init_circ(mem, lf)
  instance(bw, cache, size)
(
  this.tg_setbw(0);
  cache = mem;
  size = ceil(bw / lf) / 2 |0;
  memset(cache, 0, size);
);

function _tg_circ(t)
  instance(dt, a, cache, size)
  local(n, num, s, i)
(
  n = dt * 10;
  t >= n && t <= $pi - n ? (
    t = 2 * t - $pi;
    t >= $pi ? t -= 2*$pi;
    this.tg_falloff(sqrt($pi*$pi - t*t) / $pi);
  ) : t >= $pi + n && t <= 2*$pi - n ? (
    t = 2 * t - $pi;
    t >= $pi ? t -= 2*$pi;
    this.tg_falloff(-sqrt($pi*$pi - t*t) / $pi);

  ) : (
    s = 0.0;
    n = 1;
    num = min(this.n, size * 2);
    loop((num - 1) / 2,
      i = n / 2 |0;
      !cache[i] ? cache[i] = 1/n^(2 - exp(-1));
      s += sin(n * t) * cache[i];
      n += 2;
    );
    n < num ? (
      i = n / 2 |0;
      !cache[i] ? cache[i] = 1/n^(2 - exp(-1));
      s += a * sin(n * t) * cache[i];
    );
    (1 + exp(-2)) * s;
  );
);

function tg_circ()
  local(t)
(
  t = this.t;
  this.tg_inc();
  this._tg_circ(t);
);


// Triangle

function _tg_tri(t)
  instance(dt, a)
  local(n, s)
(
  n = dt * 8;
  t >= 0.5*$pi + n && t <= 1.5*$pi - n ? (
    this.tg_falloff(2 - t / (0.5*$pi));
  ) : t <= 0.5*$pi - n ? (
    this.tg_falloff(t / (0.5*$pi));
  ) : t >= 1.5*$pi + n ? (
    this.tg_falloff(t / (0.5*$pi) - 4);

  ) : (
    s = 0.0;
    n = 1;
    loop((this.n + 1) / 4,
      s += sin(n * t) / (n*n);
      n += 4;
    );
    this.n > 3 ? (
      n = 3;
      loop((this.n - 1) / 4,
        s -= sin(n * t) / (n*n);
        n += 4;
      );
    );
    n < this.n ? s += a * sin(n * t) / (n*n);
    8/($pi*$pi) * s;
  );
);

function tg_tri()
  local(t)
(
  t = this.t;
  this.tg_inc();
  this._tg_tri(t);
);


// Trapezoid

function _tg_trap(t)
  instance(dt, a)
  local(n, s)
(
  n = dt * 4;
  t >= 0.25*$pi + n && t <= 0.75*$pi - n ? (
    this.tg_falloff(1.0);
  ) : t >= 1.25*$pi + n && t <= 1.75*$pi - n ? (
    this.tg_falloff(-1.0);
  ) : t >= 0.75*$pi + n && t <= 1.25*$pi - n ? (
    this.tg_falloff(4 - t / (0.25*$pi));
  ) : t <= 0.25*$pi - n ? (
    this.tg_falloff(t / (0.25*$pi));
  ) : t >= 1.75*$pi + n ? (
    this.tg_falloff(t / (0.25*$pi) - 8);
  
  ) : (
    s = 0.0;
    n = 1;
    loop((this.n - 1) / 2,
      n & 4 ? (
        s -= sin(n * t) / (n*n);
      ) : (
        s += sin(n * t) / (n*n);
      );
      n += 2;
    );
    n < this.n ? s += (n & 4 ? -a : a) * sin(n * t) / (n*n);
    8*sqrt(2) / ($pi*$pi) * s;
  );
);

function tg_trap()
  local(t)
(
  t = this.t;
  this.tg_inc();
  this._tg_trap(t);
);


// Square

function _tg_sqr(t)
  instance(dt, a)
  local(n, s)
(
  n = dt * 10;
  t >= n && t <= $pi - n ? (
    this.tg_falloff(1.0);
  ) : t >= $pi + n && t <= 2*$pi - n ? (
    this.tg_falloff(-1.0);

  ) : (
    s = 0.0;
    n = 1;
    loop((this.n - 1) / 2,
      s += sin(n * t) / n;
      n += 2;
    );
    n < this.n ? s += a * sin(n * t) / n;
    4/$pi * s;
  );
);

function tg_sqr()
  local(t)
(
  t = this.t;
  this.tg_inc();
  this._tg_sqr(t);
);


// Rectangle

function tg_init_rect(mem, lf)
  instance(bw, cache, size)
(
  this.tg_setbw(0);
  cache = mem;
  size = ceil(bw / lf);
);

function tg_setpw(pw)
  instance(cache, size)
(
  pw *= 2*$pi;
  pw < this.pw || pw > this.pw ? (
    this.pw = pw;
    memset(cache, 0, size);
  );
);

function _tg_rect(t)
  instance(dt, pw, a, cache, size)
  local(pw2, n, num, s, i)
(
  n = dt * 12;
  t >= n && t <= pw - n ? (
    this.tg_falloff(2 - pw / $pi);
  ) : t >= pw + n && t <= 2*$pi - n ? (
    this.tg_falloff(pw / -$pi);

  ) : (
    pw2 = 0.5 * pw;
    t += 2*$pi - pw2;
    s = 0.0;
    n = 1;
    num = min(this.n, size + 1);
    loop(num - 2,
      i = n - 1;
      !cache[i] ? cache[i] = sin(n * pw2) / n;
      s += cos(n * t) * cache[i];
      n += 1;
    );
    n < num ? (
      i = n - 1;
      !cache[i] ? cache[i] = sin(n * pw2) / n;
      s += a * cos(n * t) * cache[i];
    );
    4/$pi * s;
  );
);

function tg_rect()
  local(t)
(
  t = this.t;
  this.tg_inc();
  this._tg_rect(t);
);


// Sawtooth

function _tg_saw(t)
  instance(dt, a)
  local(n, s)
(
  n = dt * 12;
  t <= $pi - n ? (
    this.tg_falloff(t / $pi);
  ) : t >= $pi + n ? (
    this.tg_falloff(t / $pi - 2);

  ) : (
    t += $pi;
    s = 0.0;
    n = 1;
    loop(this.n - 2,
      s -= sin(n * t) / n;
      n += 1;
    );
    n < this.n ? s -= a * sin(n * t) / n;
    2/$pi * s;
  );
);

function tg_saw()
  local(t)
(
  t = this.t;
  this.tg_inc();
  this._tg_saw(t);
);
