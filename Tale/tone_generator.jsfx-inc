desc:Fourier series bandlimited tone generator
// (c) Theo Niessink 2012, 2013
// License: GPL <http://www.gnu.org/licenses/gpl.html>

/* Example #1

   desc:Bandlimited sawtooth oscillator
   slider1:440<20,12000,1>Frequency (Hz)

   import tone_generator.jsfx-inc

   @slider
   tg.tg_setf(slider1);

   @sample
   spl0 = spl1 = 0.5 * tg.tg_saw();

   Example #2

   desc:Bandlimited rectangular oscillator
   slider1:440<20,12000,1>Frequency (Hz)
   slider2:0.30<0.10,0.90,0.01>Pulse Width

   import tone_generator.jsfx-inc

   @init

   // Store the cache at local memory index 0, and select 20 Hz as the
   // lowest frequency (= maximum cache size).
   tg.tg_init_rect(0, 20);

   @slider
   tg.tg_setf(max(20, slider1));
   tg.tg_setpw(slider2);

   @sample
   spl0 = spl1 = 0.5 * tg.tg_rect();

   Example #3

   desc:Bandlimited triangular oscillator with vibrato
   slider1:440<20,12000,1>Oscillator (Hz)
   slider2:5<1,10,0.1>Vibrato (Hz)

   import tone_generator.jsfx-inc
   import lfo.jsfx-inc

   @slider
   dt = tg.tg_setf(slider1);
   lfo.lfo_setf(slider2);

   @sample
   tg.tg_setdt(dt * 2^(lfo.lfo_sin() * 35/1200));
   spl0 = spl1 = 0.5 * tg.tg_tri();

   Setting Functions

    * tg_setf(f)
      Example: osc.tg_setf(440);
      Sets the oscillator frequency (specified in Hz).

    * tg_setdt(dt)
      Example: osc2.tg_setdt(osc1.dt);
      Sets the oscillator frequency (specified in seconds/sample).

      (To convert from Hz to seconds/sample, divide by srate.)

    * tg_setpw(pw)
      Example: osc.tg_setpw(0.30);
      Sets the pulse width (0.0..1.0) for a rectangle oscillator.

    * tg_setbw(bw)
      Example: osc.tg_setbw(12000); // 12 kHz
      Example: osc.tg_setbw(0.5);   // 0.5*srate
      Sets the bandwidth, specified in Hz (0.5..srate/2), or relative to the
      sample rate (0.0..0.5).

      Note: The bandwidth is automatically limited to a maximum of srate/2.
      If you don't set a bandwidth, then the default of 12 kHz is
      automatically set.

   Waveform Functions

    * tg_sin()  -- Sine
    * tg_half() -- Half-wave rectified sine
    * tg_full() -- Full-wave rectified sine
    * tg_circ() -- Circle
    * tg_tri()  -- Triangle
    * tg_trap() -- Trapezoid
    * tg_sqr()  -- Square
    * tg_rect() -- Rectangle (pulse)
    * tg_saw()  -- Sawtooth
    * tg_ham()  -- Hammond 88 8000 00
      Example: s = osc.tg_saw();
      Returns a sample of a waveform, and increments its phase.

   Miscellaneous Functions

    * tg_sync(t)
      Example: osc2.tg_sync(osc1.t + 0.5);
      Synchronizes the oscillator with the specified phase.

      Note: You can safely specify out or range (and even negative) values
      here.

    * tg_inc()
      Example: osc.tg_inc();
      Increments the oscillator phase.

      Note: All waveform functions automatically increment the phase.

    * tg_init_circ(mem, lf) -- Circle
    * tg_init_rect(mem, lf) -- Rectangle (pulse)
      Example: osc.tg_init_rect(0, 20);
      Sets the offset of the local memory buffer used to cache calculations,
      and the lowest frequency (in Hz) to be used. Returns the size of the
      buffer.

   Instance Variables

    * t
      Example: phase = osc.t;
      The current phase [0.0..1.0) of the oscillator.

    * dt
      Example: freq = osc.dt * srate;
      The oscillator frequency, in seconds/sample.

    * pw
      Example: duty_cycle = osc.pw;
      The pulse width (0.0..1.0) of a rectangle oscillator.

    * bw
      Example: osc2.tg_setbw(osc1.bw);
      The oscillator bandwidth, in Hz.

    * n
      Example: num_harmonics = osc.n - 1;
      The oscillator bandwidth, in harmonics. A waveform will include up to
      n-1 harmonics.

*/

@init


function tg_setbw(bw)
(
  bw <= 0 ? (
    this.bw <= 0 ? this.bw = min(12000, 0.5 * srate) : this.bw;
  ) : bw > 0.5 ? (
    this.bw = min(bw, 0.5 * srate);
  ) : (
    this.bw = bw * srate;
  );
);


function _tg_setf(f)
  instance(bw, n)
  local(f0, f1)
(
  this.tg_setbw(0);
  n = ceil(bw / f);

  n > 1 ? (
    f0 = bw / n;
    f1 = bw / (n - 1);
    sqrt((f1 - f) / (f1 - f0));
  );
);

function tg_setf(f)
  instance(a, dt)
(
  a = this._tg_setf(f);
  dt = f / srate;
);

function tg_setdt(dt)
  instance(a)
(
  a = this._tg_setf(dt * srate);
  this.dt = dt;
);


function tg_setpw(pw)
  instance(cache, size)
(
  pw < this.pw || pw > this.pw ? (
    size ? memset(cache, 0, size);
    this.pw = pw;
  );
);


function tg_sync(t)
(
  t >= 0 ? t -= t|0 : t += 1 - (t|0);
  this.t = t;
);


function tg_inc()
  instance(t, dt)
(
  t += dt;
  t -= t|0;
);


function tg_falloff(s)
  instance(n, a)
(
  n > 2 ? s : n > 1 ? a * s : 0.0;
);


// Sine

function tg_sin()
  local(t)
(
  t = this.t;
  this.tg_inc();

  this.tg_falloff(sin(2*$pi * t));
);


// Half-wave rectified sine

function tg_half()
  instance(dt, a)
  local(t, n, s)
(
  t = this.t;
  this.tg_inc();

  // Naive
  n = dt * 8;
  t >= 0.5 + n && t <= 1 - n ? (
    this.tg_falloff(-2/$pi);
  ) : t >= n && t <= 0.5 - n ? (
    this.tg_falloff(-2/$pi + 2*sin(2*$pi * t));

  // Fourier series
  ) : (
    t *= 2*$pi;
    s = 0.0;
    n = 2;
    loop((this.n - 2) / 2,
      s += cos(n * t) / (n*n - 1);
      n += 2;
    );
    n < this.n ? s += a * cos(n * t) / (n*n - 1);
    this.tg_falloff(sin(t) - 4/$pi * s);
  );
);


// Full-wave rectified sine

function tg_full()
  instance(dt, a)
  local(t, n, s)
(
  t = this.t;
  this.tg_inc();

  n = dt * 10;
  t >= n && t <= 1 - n ? (
    this.tg_falloff(-4/$pi + 2*sin($pi * t));

  ) : (
    t *= 2*$pi;
    s = 0.0;
    n = 1;
    loop(this.n - 2,
      s += cos(n * t) / (4 * n*n - 1);
      n += 1;
    );
    n < this.n ? s += a * cos(n * t) / (4 * n*n - 1);
    (-8/$pi) * s;
  );
);


// Circle

function tg_init_circ(mem, lf)
  instance(bw, cache, size)
(
  this.tg_setbw(0);
  cache = mem;
  size = lf > 0 ? ceil(bw / lf) / 2 |0 : 0;
  size ? memset(cache, 0, size);

  size;
);

function tg_circ()
  instance(dt, a, cache, size)
  local(t, n, num, s, i)
(
  t = this.t;
  this.tg_inc();

  n = dt * 10;
  t >= n && t <= 0.5 - n ? (
    t *= 2;
    t -= (t|0) + 0.5;
    this.tg_falloff(2 * sqrt(0.25 - t*t));
  ) : t >= 0.5 + n && t <= 1 - n ? (
    t *= 2;
    t -= (t|0) + 0.5;
    this.tg_falloff(-2 * sqrt(0.25 - t*t));

  ) : (
    t *= 2*$pi;
    s = 0.0;
    n = 1;

    // Cached
    size ? (
      num = min(this.n, size * 2);
      loop((num - 1) / 2,
        i = n / 2 |0;
        !cache[i] ? cache[i] = 1/n^(2 - exp(-1));
        s += sin(n * t) * cache[i];
        n += 2;
      );
      n < num ? (
        i = n / 2 |0;
        !cache[i] ? cache[i] = 1/n^(2 - exp(-1));
        s += a * sin(n * t) * cache[i];
      );

    // Cacheless
    ) : (
      loop((this.n - 1) / 2,
        s += sin(n * t) / n^(2 - exp(-1));
        n += 2;
      );
      n < this.n ? s += a * sin(n * t) / n^(2 - exp(-1));
    );

    (1 + exp(-2)) * s;
  );
);


// Triangle

function tg_tri()
  instance(dt, a)
  local(t, n, s)
(
  t = this.t;
  this.tg_inc();

  n = dt * 8;
  t >= 0.25 + n && t <= 0.75 - n ? (
    this.tg_falloff(2 - 4*t);
  ) : t <= 0.25 - n ? (
    this.tg_falloff(4*t);
  ) : t >= 0.75 + n ? (
    this.tg_falloff(4*t - 4);

  ) : (
    t *= 2*$pi;
    s = 0.0;
    n = 1;
    loop((this.n + 1) / 4,
      s += sin(n * t) / (n*n);
      n += 4;
    );
    this.n > 3 ? (
      n = 3;
      loop((this.n - 1) / 4,
        s -= sin(n * t) / (n*n);
        n += 4;
      );
    );
    n < this.n ? s += a * sin(n * t) / (n*n);
    8/($pi*$pi) * s;
  );
);


// Trapezoid

function tg_trap()
  instance(dt, a)
  local(t, n, s)
(
  t = this.t;
  this.tg_inc();

  n = dt * 4;
  t >= 0.125 + n && t <= 0.375 - n ? (
    this.tg_falloff(1.0);
  ) : t >= 0.625 + n && t <= 0.875 - n ? (
    this.tg_falloff(-1.0);
  ) : t >= 0.375 + n && t <= 0.625 - n ? (
    this.tg_falloff(4 - 8*t);
  ) : t <= 0.125 - n ? (
    this.tg_falloff(8*t);
  ) : t >= 0.875 + n ? (
    this.tg_falloff(8*t - 8);
  
  ) : (
    t *= 2*$pi;
    s = 0.0;
    n = 1;
    loop((this.n - 1) / 2,
      n & 4 ? (
        s -= sin(n * t) / (n*n);
      ) : (
        s += sin(n * t) / (n*n);
      );
      n += 2;
    );
    n < this.n ? s += (n & 4 ? -a : a) * sin(n * t) / (n*n);
    8*sqrt(2) / ($pi*$pi) * s;
  );
);


// Square

function tg_sqr()
  instance(dt, a)
  local(t, n, s)
(
  t = this.t;
  this.tg_inc();

  n = dt * 10;
  t >= n && t <= 0.5 - n ? (
    this.tg_falloff(1.0);
  ) : t >= 0.5 + n && t <= 1 - n ? (
    this.tg_falloff(-1.0);

  ) : (
    t *= 2*$pi;
    s = 0.0;
    n = 1;
    loop((this.n - 1) / 2,
      s += sin(n * t) / n;
      n += 2;
    );
    n < this.n ? s += a * sin(n * t) / n;
    4/$pi * s;
  );
);


/* // Low-pass filtered square

function tg_lpsqr()
  instance(dt, a)
  local(t, n, s, at, tmp)
(
  t = this.t;
  this.tg_inc();

  !at ? (
    // (f / fc) - sqrt(2) + 1
    tmp = 2 - sqrt(2);
    at = atan(tmp)/tmp;
  );

  n = dt * 4;
  t >= n && t <= 0.5 - n ? (
    // -at + (at + 1) * (1 - exp(-fc/f * 2*$pi * t))
    this.tg_falloff(-at + (at + 1) * (1 - exp(-2*$pi * t)));
  ) : t >= 0.5 + n && t <= 1 - n ? (
    // -1 + (at + 1) * exp(fc/f * ($pi - 2*$pi * t))
    this.tg_falloff(-1 + (at + 1) * exp($pi - 2*$pi * t));

  ) : (
    t *= 2*$pi;
    s = 0.0;
    n = 1;
    loop((this.n - 1) / 2,
      // atan(f/fc * n)
      tmp = atan(n);
      s += cos(tmp) * sin(n * t - tmp) / n;
      n += 2;
    );
    n < this.n ? (
      tmp = atan(n);
      s += a * cos(tmp) * sin(n * t - tmp) / n;
    );
    4/$pi * s;
  );
); */


// Rectangle

function tg_init_rect(mem, lf)
  instance(bw, cache, size)
(
  this.tg_setbw(0);
  cache = mem;
  size = lf > 0 ? ceil(bw / lf) : 0;
  size ? memset(cache, 0, size);

  size;
);

function tg_rect()
  instance(dt, pw, a, cache, size)
  local(t, pw2, n, num, s, i)
(
  pw <= 0 ? pw = 0.5;

  t = this.t;
  this.tg_inc();

  n = dt * 12;
  t >= n && t <= pw - n ? (
    this.tg_falloff(-2*pw + 2);
  ) : t >= pw + n && t <= 1 - n ? (
    this.tg_falloff(-2*pw);

  ) : (
    t = 2*$pi * (t + 1 - 0.5*pw);
    pw2 = $pi * pw;
    s = 0.0;
    n = 1;

    // Cached
    size ? (
      num = min(this.n, size + 1);
      loop(num - 2,
        i = n - 1;
        !cache[i] ? cache[i] = sin(n * pw2) / n;
        s += cos(n * t) * cache[i];
        n += 1;
      );
      n < num ? (
        i = n - 1;
        !cache[i] ? cache[i] = sin(n * pw2) / n;
        s += a * cos(n * t) * cache[i];
      );

    // Cacheless
    ) : (
      loop(this.n - 2,
        s += cos(n * t) * sin(n * pw2) / n;
        n += 1;
      );
      n < this.n ? s += a * cos(n * t) * sin(n * pw2) / n;
    );

    4/$pi * s;
  );
);


// Sawtooth

function tg_saw()
  instance(dt, a)
  local(t, n, s)
(
  t = this.t;
  this.tg_inc();

  n = dt * 12;
  t <= 0.5 - n ? (
    this.tg_falloff(2*t);
  ) : t >= 0.5 + n ? (
    this.tg_falloff(2*t - 2);

  ) : (
    t = 2*$pi * (t + 0.5);
    s = 0.0;
    n = 1;
    loop(this.n - 2,
      s -= sin(n * t) / n;
      n += 1;
    );
    n < this.n ? s -= a * sin(n * t) / n;
    2/$pi * s;
  );
);


// Hammond 88 8000 000

function tg_ham()
  instance(a, n)
  local(t)
(
  t = this.t;
  this.tg_inc();

  0.4 * (
    n > 4 ? sin(2*$pi * t) + sin(4*$pi * t) + sin(6*$pi * t) :
    n > 3 ? sin(2*$pi * t) + sin(4*$pi * t) + a * sin(6*$pi * t) :
    n > 2 ? sin(2*$pi * t) + a * sin(4*$pi * t) :
    n > 1 ? a * sin(2*$pi * t)
  );
);
