desc:Simple mono synth
// (c) Theo Niessink 2012, 2013
// License: GPL - http://www.gnu.org/licenses/gpl.html

slider1:-6.0<-120.0,24.0,1.0>Volume (dB)
slider2:0.0<-1200.0,1200.0,1.0>Tuning (cent)
slider4:3<0,5000,1>Attack (ms)
slider5:1000<1,15000,1>Decay (ms)
slider6:0.0<-120.0,24.0,1.0>Sustain (dB)
slider7:8<0,5000,1>Release (ms)
slider9:7<0,11,1{Sine,Half-wave rectified sine,Full-wave rectified sine,Triangle,Trapezoid,Square,Pulse,Sawtooth,Modified triangle,Triangular pulse,Hammond,Staircase}>Waveform
slider10:0.30<0.0,1.0,0.01>Pulse Width
slider12:200.0<0.0,1200.0,1.0>Pitch Wheel Range (cent)
slider14:-36.0<-36.0,0.0,1.0>White Noise (dB)
slider16:1.0<0.0,1.0,0.01>Low-Pass Filter
slider17:0<0,15000,1>Filter Decay (ms)
slider18:1.0<0.01,4.0,0.01>Filter Q

out_pin:Synth output
out_pin:Synth output

import midi_queue.jsfx-inc
import rc_filter.jsfx-inc
import zdf_filter.jsfx-inc
import poly_blep.jsfx-inc
import noise_generator.jsfx-inc


@init

midiq.midiq_init(0, 0);

inf = 10^(-120.0 / 20);
step5 = exp(-5);

lpf.m = 50;
lpf.ln = log(lpf.m);

gain.rc_set(0.0033);
lpf.rc.a = gain.a;

function set_pitch() ( pitch = pitch_range > 0.0 ? 2^(pitch_wheel / ((pitch_wheel >= 0 ? 8191 : 8192) * pitch_range)) : 1.0; );

function set_freq()
(
  tuned_freq = tuning * freq;
  tg.poly_setf(pitch * tuned_freq);
  lpf.env.a <= 0 ? lpf.freq = lpf.n * tuned_freq;
);

function adsr_a() ( adsr = 1; env.a = adsr.a; lpf.env.lp = lpf.m; );
function adsr_d() ( adsr = 2; env.a = adsr.d; );
function adsr_s() ( adsr = 3; env.lp = adsr.s * vel; );
function adsr_r() ( adsr = 4; env.a = adsr.r; );

pitch_wheel = 0;
pitch = 1.0;


@slider

function amp(db) ( db <= -120.0 ? 0.0 : 10^(db / 20); );
function rc(ms, lo, hi) ( adsr.rc_sets(0.001 * max(lo, min(hi, ms))); );

gain.in = amp(slider1);

adsr.s = amp(slider6);
adsr.r = rc(slider7, 0, 5000);
adsr.d = rc(slider5, 1, 15000);
adsr.a = rc(slider4, 0, 5000);
adsr & 2 ? adsr_d() : adsr == 4 ? adsr_r() : adsr == 1 ? adsr_a();

tuning = 2^(slider2 / 1200);

slider9|0 != wave ? (
  wave = slider9|0;
  tg.poly_resetf();
  // Resync leaky integrator(s)
  tg.poly_leaky_reset();
);

// Pulse
wave == 6 ? tg.poly_setpw(max(0.10, min(0.90, slider10))) :
// Modified triangle
wave == 8 ? tg.poly_setpw(max(0.01, min(0.99, slider10)));

noise = slider14 <= -36.0 ? 0.0 : 10^(slider14 / 20);

lpf.n = slider16 >= 1.0 ? lpf.m : exp(max(0.0, slider16) * lpf.ln);
slider17 < 1 ? lpf.env.a = 0 : lpf.env.rc_sets(0.001 * min(15000, slider17));

pitch_range = slider12 > 0.0 ? 1200 / slider12 : 0.0;
set_pitch();
set_freq();

lpf.q = max(0.01, min(4.0, slider18));
lpf.zdf.zdf_lp(lpf.rc.lp, lpf.q);


@block

midiq.midiq_collect();


@sample

while(
  midiq.midiq_remove() ? (
    midiq.msg1 &= 0xF0;
    midiq.msg2  = midiq.msg23 & 0x7F;
    midiq.msg23 = midiq.msg23 >> 8;

    // Note On
    midiq.msg1 == 0x90 && midiq.msg23 ? (
      note = midiq.msg2;
      freq = 440.0 * 2^((note - 69) / 12);
      vel = midiq.msg23 / 127;
      set_freq();
      hold = 0;
      adsr_a();
    ) :

    // Note Off
    midiq.msg1 == 0x80 || (midiq.msg1 == 0x90 && !midiq.msg23) ? (
      midiq.msg2 == note ? !pedal ? adsr_r() : hold = 1;
    ) :

    // Pitch Wheel
    midiq.msg1 == 0xE0 ? (
      pitch_wheel = (midiq.msg23 << 7 | midiq.msg2) - 8192;
      set_pitch();
      set_freq();
    ) :

    // Control Change
    midiq.msg1 == 0xB0 ? (

      // Damper Pedal (Sustain)
      midiq.msg2 == 64 ? (
        pedal = midiq.msg23 >= 64;
        !pedal && hold ? adsr_r();
      ) :

      // All Notes Off
      midiq.msg2 == 123 ? (
        adsr_r();
      );
    );

    1; // while midiq.midiq_remove()
  );
);

gain.rc_lp(gain.in);

adsr <= 0 ? s = 0.0 : (
  // Sustain
  adsr == 3 ? (
    1;
  ) :

  // Decay
  adsr == 2 ? (
    s = adsr.s * vel;
    env.rc_lp(s);
    abs(env.lp - s) <= inf ? adsr_s();
  ) :

  // Release
  adsr == 4 ? (
    env.rc_lp(0.0);
    env.lp <= inf ? adsr = env.lp = 0;;
  ) :

  // Attack
  adsr == 1 ? (
    env.rc_lp(vel);
    abs(env.lp - vel) <= step5 ? adsr_d();
  );

  noise < 1.0 ? (
    s = wave == 7  ? tg.poly_saw():
        wave == 6  ? tg.poly_rect():
        wave == 5  ? tg.poly_sqr():
        wave == 4  ? tg.poly_trap():
        wave == 3  ? tg.poly_tri():
        wave == 2  ? tg.poly_full():
        wave == 1  ? tg.poly_half():
        wave == 0  ? tg.poly_sin():
        wave == 8  ? tg.poly_tri2():
        wave == 9  ? tg.poly_trip():
        wave == 10 ? tg.poly_ham():
      /*wave == 11*/ tg.poly_stairs();
    noise > 0.0 ? s = noise * (noise.lcg_white()) + (1.0 - noise) * s;
  ) : (
    s = noise.lcg_white();
  );

  s *= gain.lp * env.lp;
);

lpf.env.a > 0 ? lpf.freq = lpf.env.rc_lp(lpf.n) * tuned_freq;
lpf.rc.rc_lp(lpf.freq);

// Recalculate LPF coefficients only every 16 samples
lpf.skip > 0 ? lpf.skip -= 1 : (
  lpf.skip = 16 - 1;

  lpf.rc.lp != lpf.zdf.freq ? (
    lpf.zdf.freq = lpf.rc.lp;
    lpf.zdf.zdf_lp(lpf.rc.lp, lpf.q);
  );
);

lpf.n < lpf.m ? s = lpf.zdf.zdf_svf_lp(s) : lpf.zdf.zdf_svf_lp(s);

spl0 += s;
spl1 += s;
